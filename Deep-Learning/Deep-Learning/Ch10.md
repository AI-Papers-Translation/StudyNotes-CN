# C10. 序列建模：循环和递归网络

循环神经网络 ( Recurrent Neural Networks, RNN ) 是用于处理序列数据的神经网络，序列数据的长度既可以是固定的，也可以是变长的。

在模型的不同部分共享参数，参数共享使得模型能够扩展到不同形式的样本并进行泛化：

-   卷积操作允许网络跨时间共享参数，输出是一个序列，输出中的每一项是相邻几项输入的数据，利用每个时间步中使用相同的卷积核实现参数共享
-   循环操作使得输出的每一项是前一项的函数，输出的每一项对先前的输出应用相同的更新规则产生，从而通过很深的计算图实现参数共享

## 10.1 展开计算图

计算图是形式化一组计算结构的方式。 ( [Sec 6.5.1](Ch06.md) )

-   展开 ( unfolding ) 递归或者循环计算得到的重复结构解释深度网络结构中的参数共享

动态系统的经典形式 ( 图 10-1 ) ：$\pmb{s}^{( t )}=f ( \pmb{s}^{( t-1 )};\pmb{\theta} )$

-   系统的状态：$\pmb{s}^{( t )}$

由外部信号$\pmb{x}^{( t )}$驱动的动态系统：$\pmb{s}^{( t )}=f ( \pmb{s}^{( t-1 )},\pmb{x}^{( t )};\pmb{\theta} )$

-   系统当前的状态包含了整个过去序列的信息

网络的隐藏单元的状态表示 ( 图 10-2 ) ：$\pmb{h}^{( t )}=f ( \pmb{h}^{( t-1 )},\pmb{x}^{( t )};\pmb{\theta} ) =g^{( t )} ( \pmb{x}^{( t )},\pmb{x}^{( t-1 )},\pmb{x}^{( t-1 )},\cdots,\pmb{x}^{( 2 )},\pmb{x}^{( 1 )} )$

-   函数$g^{( t )}$将全部的过去序列$( \pmb{x}^{( t )},\pmb{x}^{( t-1 )},\pmb{x}^{( t-2 )},\cdots,\pmb{x}^{( 2 )},\pmb{x}^{( 1 )} )$作为输入来生成当前的状态，即利用展开的循环结构将函数$g^{( t )}$分解为函数$f$的递归运算

引入展开过程的两个主要优点：

-   不受序列长度的影响，学成的模型始终具有相同的输入大小，因为它指定的是从一种状态到另一种状态的转移，而不是在可变长度的历史状态上操作
-   在每个时间步使用相同参数的相同的转移函数$f$

## 10.2 循环神经网络

循环神经网络的重要设计模式

-   ( 图 10-3 ) 每个时间步都产生一个输出，并且隐藏单元之间有循环连接的循环网络
    -   将输入序列的值$\pmb{x}$映射到输出序列的值$\pmb{o}$，输入序列与输出序列是相同的长度
    -   损失$L$衡量每个输出$\pmb{o}$与对应的目标$\pmb{y}$之间的距离，输入序列$\pmb{x}$与目标序列$\pmb{y}$的总损失就是所有时间步的损失之和
    -   可以将需要的关于过去任何信息放入隐藏表示 $\pmb{h}$ 中，并且基于 $\pmb{h}$ 传播到未来
-   ( 图 10-4 ) 每个时间步都产生一个输出，但是只有当前时刻的输出单元到下个时刻的隐藏单元之间有循环连接的循环网络
    -   可以将特定的输出值放入 $\pmb{o}$ 中，并且 $\pmb{o}$ 是允许传播到未来的唯一信息
-   ( 图 10-5 ) 读取整个序列后产生单个输出，隐藏单元之间有循环连接的循环网络

 ( 图 10-3 ) 循环神经网络的数学描述：

-   权重矩阵$\pmb{U}$表示输入到隐藏的连接
-   权重矩阵$\pmb{W}$表示隐藏到隐藏的循环连接
-   权重矩阵$\pmb{V}$表示隐藏到输出的连接
-   偏置：$\pmb{b}$ 和 $\pmb{c}$
-   反向传播算法称为通用时间反向传播 ( Back-Propagation Through Time, BPTT, Sec 10.2.2 )
    -   梯度计算的运行时间是$\mathcal{O} ( \tau )$，并且无法并行运算，因为前向传播图是固定顺序的，每个不只能依序计算
    -   梯度运算的内存代价是$\mathcal{O} ( \tau )$，因为前向传播中的各个状态必须保存，直到它们在反向传播中被再次使用

$$
\begin{align}
    \pmb{a}^{( t )}&=\pmb{b}+\pmb{Wh}^{( t-1 )}+\pmb{Ux}^{( t )}\\
    \pmb{h}^{( t )}&=\tanh ( \pmb{a}^{( t )} ) \\
    \pmb{o}^{( t )}&=\pmb{c}+\pmb{Vh}^{( t )}\\
    \hat{\pmb{y}}^{( t )}&=\text{softmax} ( \pmb{o}^{( t )} ) \\
\end{align}
$$

$$
\begin{aligned}
    L ( \{\pmb{x}^{( 1 )},\cdots,\pmb{x}^{( \tau )}\},\{\pmb{y}^{( 1 )},\cdots,\pmb{y}^{\tau}\} )
        &=\sum_t L^{( t )}    \\
        &=-\sum_t\log p_{\text{model}} ( y^{( t )}|\{\pmb{x}^{( 1 )},\cdots,\pmb{x}^{( \tau )}\} )
\end{aligned}
$$

### 10.2.1 导师驱动过程和输出循环网络

 ( 图 10-4 )

-   缺点：仅在一个时间步的输出和下一个时间步的隐藏单元间存在循环连接的网络，不能模拟通用的图灵机。因为输出单元无法捕捉过去的所有信息用于预测未来，除非用户知道如何描述系统的全部状态，并且将这些状态作为训练目标的一部分
-   优点：任何基于比较时刻$t$的预测和时刻$t$的训练目标的损失函数中的所有时间步都解耦了。因为训练集提供输出的理想值，所以没有必要先计算前一时刻的输出，因此训练可以并行化，即在各时刻$t$分别计算梯度。
-   由输出反馈到模型而产生循环连接的模型可以使用的训练方法
    -   导师驱动过程 ( Teacher Forcing ) ：适用于输出与下一个时间步的隐藏状态存在连接的 RNN。不再使用最大似然准则，而是时刻$t+1$接收真实值$y^{( t )}$作为输入
        -   如果网络在开环 ( open-loop ) 模式下使用，即网络的输出 ( 或者输出分布的样本 ) 反馈作为输入，那么训练期间网络看到的输入与测试期间网络看到的输入会有区别，那么使用导师驱动过程和自由运行的输入进行训练才能使网络学会在训练期间没有接触到的输入条件
    -   BPTT 算法：如果隐藏单元是较早时间步的函数，BPTT 算法是必要的那么需要同时使用导师驱动过程和 BPTT
